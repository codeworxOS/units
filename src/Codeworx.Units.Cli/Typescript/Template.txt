//----------------------
// <auto-generated>
//     Generated using Codeworx.Units.Cli
// </auto-generated>
//----------------------

export function isIDimension(obj: any): obj is IDimension {
  return obj?.toUnit != undefined && obj?.symbol != undefined && obj.value != undefined;
}

export type UnitSystems = 'Metric' | 'Imperial';

export type DimensionName = {{{Names}}};
export const DimensionNameList: DimensionName[] = [{{{NameList}}}];

export interface IDimension {
  value: number;
  symbol: string;
  dimension: string;
  system: UnitSystems[];
  toUnit(symbol: string): IDimension;
}

{{#Dimensions}}
export abstract class I{{{DimensionName}}} implements IDimension {
    public static DefaultSymbol: string = "{{{DefaultUnit}}}";

    public static SISymbol: string = "{{{SIUnit}}}";

    public static ImperialSymbol: string = "{{{DefaultImperial}}}";

    public static MetricSymbol: string = "{{{DefaultMetric}}}";

    public value: number;

    public symbol: string;

    public system: UnitSystems[];

    public dimension: string = "{{{DimensionName}}}";

    public constructor(val: number, sym: string, system: UnitSystems[]) {
        this.value = val;
        this.symbol = sym;
        this.system = system;
    }
{{#Units}}
    public abstract To{{{UnitName}}}(): {{{UnitName}}};
{{/Units}}

    public abstract toJSON(): string;

    public static fromJS(json: any): I{{{DimensionName}}} {
        if (json instanceof I{{{DimensionName}}}) {
            return json;
        }

        return I{{{DimensionName}}}.parse(json);
    }

    public static parse(text: string): I{{{DimensionName}}} {
        var idx = text.indexOf(' ');

        if (idx != -1) {
            var valuePart = text.substring(0, idx);
            var value: number = +valuePart;

            if (value == undefined)
                throw new Error("Value could not be parsed. " + valuePart);

            return I{{{DimensionName}}}.parseWithSymbol(text.substring(idx + 1), value);
        }
        else {
            throw new Error("Unit not recognizable from input string. " + text);
        }
    }

    public static parseWithSymbol(symbol: string, value: number): I{{{DimensionName}}} {
        switch (symbol) {

{{#Units}}
            case "{{{Symbol}}}":
                return new {{{UnitName}}}(value);
{{/Units}}
            default:
                throw new Error("Symbol " + symbol + " not supported.");
        }
    }

    public static getSymbols() : string[] {
        var symbols : string[] = [];

{{#Units}}
        symbols.push("{{{Symbol}}}");
{{/Units}}

        return symbols;
    }

    public toUnit(symbol: string): I{{{DimensionName}}} {
        switch (symbol) {

{{#Units}}
            case "{{{Symbol}}}":
                return this.To{{{UnitName}}}();
{{/Units}}
            default:
                throw new Error("Symbol " + symbol + " not supported.");
        }
    }

    public toString(): string {
        return this.toJSON();
    }
}

{{#Units}}
export class {{{UnitName}}} extends I{{{DimensionName}}} {
    
    public constructor(val: number) {
        super(val, "{{{Symbol}}}", [{{{SystemString}}}]);
    }

{{#Conversion}}
    public To{{{ConversionUnitName}}}(): {{{ConversionUnitName}}} {
        {{^HasConversion}}
            return this;
        {{/HasConversion}}
        {{#HasConversion}}
            return new {{{ConversionUnitName}}}({{{Conversion}}});
        {{/HasConversion}}
    }
{{/Conversion}}

    public toJSON(): string {
        return (this.value + " {{{Symbol}}}");
    }
}
{{/Units}}
{{/Dimensions}}

export class DimensionHelper {
  constructor(public parse: (value: string) => IDimension, public parseWithSymbol: (symbol: string, value: number) => IDimension, public getSymbols: () => string[], public defaultSymbol: string, public metricSymbol: string, public imperialSymbol: string) { }

  public static GetHelper(
    dimensionName: DimensionName
  ): DimensionHelper
  {
    switch (dimensionName) {
    
{{#Dimensions}}
      case '{{{DimensionName}}}':
        return new DimensionHelper(I{{{DimensionName}}}.parse, I{{{DimensionName}}}.parseWithSymbol, I{{{DimensionName}}}.getSymbols, I{{{DimensionName}}}.DefaultSymbol, I{{{DimensionName}}}.MetricSymbol, I{{{DimensionName}}}.ImperialSymbol);
{{/Dimensions}}
    }

    throw Error('Invalid dimensionName "' + dimensionName + '"!');
  }
}