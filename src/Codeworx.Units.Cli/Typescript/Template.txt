//----------------------
// <auto-generated>
//     Generated using Codeworx.Units.Cli
// </auto-generated>
//----------------------

export function isIDimension(obj: any): obj is IDimension {
  return obj?.toUnit != undefined && obj?.symbol != undefined && obj.value != undefined;
}

export type DimensionName = {{{Names}}};
export const DimensionNameList: DimensionName[] = [{{{NameList}}}];

export interface IDimension {
  value: number;
  symbol: string;
  dimension: string;
  toUnit(symbol: string): IDimension;
}

{{#Dimensions}}
export abstract class I{{{DimensionName}}} implements IDimension {
    public static DefaultSymbol: string = "{{{DefaultUnit}}}";

    public static SISymbol: string = "{{{SIUnit}}}";

    public static ImperialSymbol: string = "{{{DefaultImperial}}}";

    public static MetricSymbol: string = "{{{DefaultMetric}}}";

    public value: number;

    public symbol: string;

    public dimension: string = "{{{DimensionName}}}";

    public constructor(val: number, sym: string) {
        this.value = val;
        this.symbol = sym;
    }
{{#Units}}
    public abstract To{{{UnitName}}}(): {{{DimensionName}}}{{{UnitName}}};
{{/Units}}

    public abstract toJSON(): string;

    public static fromJS(json: any): I{{{DimensionName}}} {
        if (json instanceof I{{{DimensionName}}}) {
            return json;
        }

        return I{{{DimensionName}}}.parse(json);
    }

    public static parse(text: string): I{{{DimensionName}}} {
        var idx = text.indexOf(' ');

        if (idx != -1) {
            var valuePart = text.substring(0, idx);
            var value: number = +valuePart;

            if (value == undefined)
                throw new Error("Value could not be parsed. " + valuePart);

            return I{{{DimensionName}}}.parseWithSymbol(text.substring(idx + 1), value);
        }
        else {
            throw new Error("Unit not recognizable from input string. " + text);
        }
    }

    public static parseWithSymbol(symbol: string, value: number): I{{{DimensionName}}} {
        switch (symbol) {

{{#Units}}
            case "{{{Symbol}}}":
                return new {{{DimensionName}}}{{{UnitName}}}(value);
{{/Units}}
            default:
                throw new Error("Symbol " + symbol + " not supported.");
        }
    }

    public toUnit(symbol: string): I{{{DimensionName}}} {
        switch (symbol) {

{{#Units}}
            case "{{{Symbol}}}":
                return this.To{{{UnitName}}}();
{{/Units}}
            default:
                throw new Error("Symbol " + symbol + " not supported.");
        }
    }

    public toString(): string {
        return this.toJSON();
    }
}

{{#Units}}
export class {{{DimensionName}}}{{{UnitName}}} extends I{{{DimensionName}}} {
    
    public constructor(val: number) {
        super(val, "{{{Symbol}}}");
    }

{{#ConversionUnits}}
    public To{{{ConversionUnitName}}}(): {{{DimensionName}}}{{{ConversionUnitName}}} {
        {{^HasConversion}}
            return this;
        {{/HasConversion}}
        {{#HasConversion}}
            return new {{{DimensionName}}}{{{ConversionUnitName}}}({{{Conversion}}});
        {{/HasConversion}}
    }
{{/ConversionUnits}}

    public toJSON(): string {
        return (this.value + " {{{Symbol}}}");
    }
}
{{/Units}}
{{/Dimensions}}