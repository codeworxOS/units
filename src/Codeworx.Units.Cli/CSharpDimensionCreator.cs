using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Codeworx.Units.Cli.Data;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Codeworx.Units.Cli
{
    public class CSharpDimensionCreator : BaseDimensionProcessor
    {
        private readonly Dictionary<string, JsonDimension> _dimensionData;

        public CSharpDimensionCreator(Options options, Dictionary<string, JsonDimension> dimensionData) : base(options)
        {
            _dimensionData = dimensionData;
        }

        public async Task<bool> ProcessAsync()
        {
            await Task.Yield();

            List<FileGenerationInfo> generateEntries = new();

            foreach ((var dimensionName, var dimensionData) in _dimensionData)
            {
                var dimensionClassName = dimensionName.GetClassName();
                WriteVerboseInfo($"Generating {dimensionClassName}");

                generateEntries.Add(GetInterface(dimensionClassName, dimensionData));

                generateEntries.AddRange(GetImplementations(dimensionClassName, dimensionData));
            }

            generateEntries.Add(GetExtensionSyntax());

            var sourceDirectory = new FileInfo(CurrentOptions.Input).DirectoryName!;
            foreach (var sourceFile in generateEntries)
            {
                var fileName = $"{sourceFile.ClassName}.cs";
                var filePath = Path.Combine(sourceDirectory,
                                    CurrentOptions.OutputDir!,
                                    sourceFile.Folder,
                                    fileName);

                WriteVerboseInfo($"Writing {fileName}.");

                Directory.CreateDirectory(new FileInfo(filePath).DirectoryName!);
                using (var stream = File.Create(filePath))
                using (var writer = new StreamWriter(stream))
                {
                    sourceFile.Code.WriteTo(writer);
                }
            }

            return true;
        }

        private FileGenerationInfo GetExtensionSyntax()
        {
            var template = "public static class UnitExtensions { }";

            var declaration = (SyntaxFactory.ParseMemberDeclaration(template) as ClassDeclarationSyntax)!;

            var templateAddUnitConverter = "public static void AddUnitConverters(this IList<JsonConverter> list) { }";

            var addUnitConverterMethodSyntax = (SyntaxFactory.ParseMemberDeclaration(templateAddUnitConverter) as MethodDeclarationSyntax)!;

            addUnitConverterMethodSyntax = addUnitConverterMethodSyntax.AddBodyStatements(GetRegisterConverterStatements().ToArray());

            declaration = declaration.AddMembers(addUnitConverterMethodSyntax);

            var templateAddEntityInformation = "public static IEnumerable<(string Key, string Symbol, decimal Offset, decimal Factor, decimal Divisior)> AddUnitConverters() { }";

            var templateAddEntityInformationMethodSyntax = (SyntaxFactory.ParseMemberDeclaration(templateAddEntityInformation) as MethodDeclarationSyntax)!;

            templateAddEntityInformationMethodSyntax = templateAddEntityInformationMethodSyntax.AddBodyStatements(GetEntityInfromationStatements().ToArray());

            declaration = declaration.AddMembers(templateAddEntityInformationMethodSyntax);

            var result = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(CurrentOptions.Namespace))
              .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Collections.Generic")))
              .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Text.Json.Serialization")))
              .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("Codeworx.Units.Primitives")))
              .AddMembers(declaration)
              .WithLeadingTrivia(SyntaxFactory.SyntaxTrivia(SyntaxKind.SingleLineCommentTrivia, "// <auto-generated />"))
              .NormalizeWhitespace();

            return new FileGenerationInfo(".", "UnitExtensions", result);
        }

        private IEnumerable<StatementSyntax> GetRegisterConverterStatements()
        {
            var statementTemplate = "list.Add(new UnitJsonConverter<tmp_Interface>(tmp_Interface.Parse));";
            foreach ((var dimensionName, var dimensionData) in _dimensionData)
            {
                var dimensionClassName = dimensionName.GetClassName();

                var statement = SyntaxFactory.ParseStatement(statementTemplate);

                while (statement.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Any(d => d.Identifier.Text == "tmp_Interface"))
                {
                    var identifierNode = statement.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Where(d => d.Identifier.Text == "tmp_Interface").First();
                    statement = statement.ReplaceNode(identifierNode, SyntaxFactory.IdentifierName("I" + dimensionClassName));
                }

                yield return statement;
            }
        }

        private IEnumerable<StatementSyntax> GetEntityInfromationStatements()
        {
            var statementTemplate = "yield return (\"{0}\", \"{1}\", {2}M, {3}M, {4}M);";
            foreach ((var dimensionName, var dimensionData) in _dimensionData)
            {

                foreach ((var unitName, var unitData) in dimensionData.Units)
                {
                    var statement = SyntaxFactory.ParseStatement(string.Format(CultureInfo.InvariantCulture, statementTemplate, unitData.Key, unitData.Symbol, unitData.Offset, unitData.Factor, unitData.Divisor));

                    yield return statement;
                }
            }
        }

        private FileGenerationInfo GetInterface(string dimensionClassName, JsonDimension dimensionData)
        {
            string template = $"public interface tmp_Interface : IUnitBase, IComparable {{}}";

            var interfaceDeclaration = (SyntaxFactory.ParseMemberDeclaration(template) as InterfaceDeclarationSyntax)!;

            var attribArguments = SyntaxFactory.ParseAttributeArgumentList($"(typeof(DimensionTypeConverter<I{dimensionClassName}>))");
            var list = SyntaxFactory.SeparatedList<AttributeSyntax>();
            list = list.Add(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("TypeConverter"), attribArguments));
            interfaceDeclaration = interfaceDeclaration.AddAttributeLists(SyntaxFactory.AttributeList(list));
            interfaceDeclaration = interfaceDeclaration.WithIdentifier(SyntaxFactory.Identifier("I" + dimensionClassName));

            interfaceDeclaration = interfaceDeclaration.AddMembers(GetInterfaceMethodDeclarations(dimensionClassName, dimensionData).ToArray());

            interfaceDeclaration = interfaceDeclaration.AddMembers(GetStaticInterfaceMembers(dimensionClassName, dimensionData).ToArray());

            var result = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(CurrentOptions.Namespace))
                .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")))
                .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.ComponentModel")))
                .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("Codeworx.Units.Primitives")))
                .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Globalization")))
              .AddMembers(interfaceDeclaration)
              .WithLeadingTrivia(SyntaxFactory.SyntaxTrivia(SyntaxKind.SingleLineCommentTrivia, "// <auto-generated />"))
              .NormalizeWhitespace();

            return new FileGenerationInfo(".", "I" + dimensionClassName, result);
        }

        private IEnumerable<MemberDeclarationSyntax> GetInterfaceMethodDeclarations(string dimensionClassName, JsonDimension dimensionData)
        {
            foreach ((var unitName, var unitData) in dimensionData.Units)
            {
                var unitClassName = unitName.GetClassName();
                var memberIdentifier = SyntaxFactory.Identifier("To" + unitClassName);

                var methodDeclaration = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName(dimensionClassName + "Dimension." + unitClassName), memberIdentifier);

                methodDeclaration = methodDeclaration.WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));

                yield return methodDeclaration;
            }

            {
                var methodDeclaration = (SyntaxFactory.ParseMemberDeclaration("new tmp_Interface ToUnit(string symbol);") as MethodDeclarationSyntax)!;

                while (methodDeclaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Any(d => d.Identifier.Text == "tmp_Interface"))
                {
                    var identifierNode = methodDeclaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Where(d => d.Identifier.Text == "tmp_Interface").First();
                    methodDeclaration = methodDeclaration.ReplaceNode(identifierNode, SyntaxFactory.IdentifierName("I" + dimensionClassName));
                }

                yield return methodDeclaration;
            }
        }

        private IEnumerable<FileGenerationInfo> GetImplementations(string dimensionClassName, JsonDimension dimensionData)
        {
            foreach ((var unitName, var unitData) in dimensionData.Units)
            {
                var unitClassName = unitName.GetClassName();
                var unitKey = unitData.Key;
                string template = $"public struct tmp_Struct {{private readonly decimal _value; decimal IUnitBase.BaseValue => _value; public string Symbol => \"{unitData.Symbol}\"; public string Key => \"{unitKey}\"; public UnitSystem System => UnitSystem.{unitData.System ?? Primitives.UnitSystem.Both};public string DefaultImperial => I{dimensionClassName}.DefaultImperial;public string DefaultMetric => I{dimensionClassName}.DefaultMetric; }}";

                var classDeclaration = (SyntaxFactory.ParseMemberDeclaration(template) as StructDeclarationSyntax)!;

                var attribArguments = SyntaxFactory.ParseAttributeArgumentList($"(typeof(DimensionTypeConverter<I{dimensionClassName}>))");
                var list = SyntaxFactory.SeparatedList<AttributeSyntax>();
                list = list.Add(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("TypeConverter"), attribArguments));
                classDeclaration = classDeclaration.AddAttributeLists(SyntaxFactory.AttributeList(list));

                classDeclaration = classDeclaration.WithIdentifier(SyntaxFactory.Identifier(unitClassName));

                classDeclaration = classDeclaration.AddBaseListTypes(SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseTypeName("I" + dimensionClassName)));

                classDeclaration = classDeclaration.AddMembers(GetImplementationConstructor(unitClassName));

                classDeclaration = classDeclaration.AddMembers(GetImplementationMethodsFromInterface(dimensionClassName, dimensionData, unitData).ToArray());

                classDeclaration = classDeclaration.AddMembers(GetImplementationOverrides(dimensionClassName, unitClassName, unitData).ToArray());

                var result = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(CurrentOptions.Namespace + "." + dimensionClassName + "Dimension"))
                  .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")))
                  .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Globalization")))
                  .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.ComponentModel")))
                  .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("Codeworx.Units.Primitives")))
                  .AddMembers(classDeclaration)
                  .WithLeadingTrivia(SyntaxFactory.SyntaxTrivia(SyntaxKind.SingleLineCommentTrivia, "// <auto-generated />"))
                  .NormalizeWhitespace();

                yield return new FileGenerationInfo(dimensionClassName, unitClassName, result);
            }
        }

        private ConstructorDeclarationSyntax GetImplementationConstructor(string unitName)
        {
            string template = @"public tmp_CLASS(decimal val){_value = val;}";

            var constructorDeclaration = (SyntaxFactory.ParseMemberDeclaration(template) as ConstructorDeclarationSyntax)!;

            constructorDeclaration = constructorDeclaration.WithIdentifier(SyntaxFactory.Identifier(unitName));

            return constructorDeclaration;
        }

        private IEnumerable<MemberDeclarationSyntax> GetImplementationMethodsFromInterface(string dimensionClassName, JsonDimension dimensionData, JsonUnit sourceUnit)
        {
            foreach ((var unitName, var unitData) in dimensionData.Units)
            {
                var unitClassName = unitName.GetClassName();

                var memberIdentifier = SyntaxFactory.Identifier("To" + unitClassName);

                var methodDeclaration = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName(unitClassName), memberIdentifier);

                methodDeclaration = methodDeclaration.WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword)));

                if (sourceUnit == unitData)
                {
                    methodDeclaration = methodDeclaration.WithExpressionBody(SyntaxFactory.ArrowExpressionClause(SyntaxFactory.ThisExpression()));
                    methodDeclaration = methodDeclaration.WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
                }
                else
                {
                    var body = SyntaxFactory.Block();

                    var template = "return new tmp_Struct();";

                    var returnStatement = SyntaxFactory.ParseStatement(template);

                    var identifierNode = returnStatement.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Where(d => d.Identifier.Text == "tmp_Struct").First();

                    returnStatement = returnStatement.ReplaceNode(identifierNode, SyntaxFactory.IdentifierName(unitClassName));

                    var objectCreation = returnStatement.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<ObjectCreationExpressionSyntax>().First();

                    returnStatement = returnStatement.ReplaceNode(objectCreation, GetObjectCreationFromConversion(objectCreation, dimensionData, sourceUnit, unitData));

                    body = body.AddStatements(returnStatement);

                    methodDeclaration = methodDeclaration.WithBody(body);
                }

                yield return methodDeclaration;
            }

            var parseTemplates = new[]
            {
        "public tmp_Interface ToUnit(string symbol) { switch (symbol){ } throw new NotSupportedException($\"Symbol {symbol} not supported.\"); }",
        "IUnitBase IUnitBase.ToUnit(string symbol) { switch (symbol){ } throw new NotSupportedException($\"Symbol {symbol} not supported.\"); }",
      };

            foreach (var parseTemplate in parseTemplates)
            {
                var declaration = (SyntaxFactory.ParseMemberDeclaration(parseTemplate) as MethodDeclarationSyntax)!;

                while (declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Any(d => d.Identifier.Text == "tmp_Interface"))
                {
                    var identifierNode = declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Where(d => d.Identifier.Text == "tmp_Interface").First();
                    declaration = declaration.ReplaceNode(identifierNode, SyntaxFactory.IdentifierName("I" + dimensionClassName));
                }

                var originalSwitch = declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<SwitchStatementSyntax>().Single();

                var newSwitch = originalSwitch;

                foreach ((var unitName, var unitData) in dimensionData.Units)
                {
                    var unitClassName = unitName.GetClassName();
                    var switchLabels = SyntaxFactory.List<SwitchLabelSyntax>().Add(SyntaxFactory.CaseSwitchLabel(SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(unitData.Symbol))));

                    var parserReturnTemplate = "return to_TmpStruct();";

                    var returnDeclaration = SyntaxFactory.ParseStatement(parserReturnTemplate);

                    while (returnDeclaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Any(d => d.Identifier.Text == "to_TmpStruct"))
                    {
                        var identifierNode = returnDeclaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Where(d => d.Identifier.Text == "to_TmpStruct").First();

                        returnDeclaration = returnDeclaration.ReplaceNode(identifierNode, SyntaxFactory.IdentifierName("To" + unitClassName));
                    }

                    newSwitch = newSwitch.AddSections(SyntaxFactory.SwitchSection(switchLabels, SyntaxFactory.List<StatementSyntax>().Add(returnDeclaration)));
                }

                declaration = declaration.ReplaceNode(originalSwitch, newSwitch);

                yield return declaration;
            }
        }

        private SyntaxNode GetObjectCreationFromConversion(ObjectCreationExpressionSyntax objectCreation, JsonDimension dimensionData, JsonUnit sourceUnit, JsonUnit targetUnit)
        {
            var conversionPath = dimensionData.GetConversionPath(sourceUnit, targetUnit);

            if (conversionPath == null)
            {
                WriteWarningOutput($"Invalid Conversion {dimensionData.Name}");
            }

            ExpressionSyntax conversionExpression = (conversionPath ?? []).GetConversionExpression();

            var arg = SyntaxFactory.Argument(conversionExpression);

            var argList = SyntaxFactory.ArgumentList(default);
            argList = argList.AddArguments(arg);

            return objectCreation.WithArgumentList(argList);
        }

        private IEnumerable<MemberDeclarationSyntax> GetImplementationOverrides(string dimensionClassName, string unitClassName, JsonUnit unitData)
        {
            var templates = new List<string>();

            templates.AddRange(new[]
            {
                "public static implicit operator tmp_Struct(decimal value) { return new tmp_Struct(value); }",
                "public static tmp_Struct operator +(tmp_Struct first, tmp_Interface second) { return new tmp_Struct(first._value + second.tmp_ToStruct()._value); }",
                "public static tmp_Struct operator -(tmp_Struct first, tmp_Interface second) { return new tmp_Struct(first._value - second.tmp_ToStruct()._value); }",
                "public static tmp_Struct operator +(tmp_Struct first, decimal second) { return new tmp_Struct(first._value + second); }",
                "public static tmp_Struct operator -(tmp_Struct first, decimal second) { return new tmp_Struct(first._value - second); }",
                "public static tmp_Struct operator *(tmp_Struct first, decimal second) { return new tmp_Struct(first._value * second); }",
                "public static tmp_Struct operator /(tmp_Struct first, decimal second) { return new tmp_Struct(first._value / second); }",
                "public static decimal operator /(tmp_Struct first, tmp_Interface second) { return first._value / second.tmp_ToStruct()._value; }",

                "public static tmp_Struct operator -(tmp_Struct first) { return new tmp_Struct(-first._value); }",

                "public static bool operator >(tmp_Struct first, tmp_Interface second) { return first._value > second.tmp_ToStruct()._value; }",
                "public static bool operator >=(tmp_Struct first, tmp_Interface second) { return first._value >= second.tmp_ToStruct()._value; }",
                "public static bool operator <(tmp_Struct first, tmp_Interface second) { return first._value < second.tmp_ToStruct()._value; }",
                "public static bool operator <=(tmp_Struct first, tmp_Interface second) { return first._value <= second.tmp_ToStruct()._value; }",
            });


            templates.AddRange(new[]
            {
                "public static bool operator ==(tmp_Struct first, tmp_Interface second) { return first._value == second.tmp_ToStruct()._value; }",
                "public static bool operator !=(tmp_Struct first, tmp_Interface second) { return first._value != second.tmp_ToStruct()._value; }",
            });

            templates.AddRange(new[]
            {
                "public static bool operator >(tmp_Struct first, tmp_Struct second) { return first._value > second._value; }",
                "public static bool operator >=(tmp_Struct first, tmp_Struct second) { return first._value >= second._value; }",
                "public static bool operator <(tmp_Struct first, tmp_Struct second) { return first._value < second._value; }",
                "public static bool operator <=(tmp_Struct first, tmp_Struct second) { return first._value <= second._value; }"
            });

            templates.AddRange(new[]
            {
                "public static bool operator ==(tmp_Struct first, tmp_Struct second) { return first._value == second._value; }",
                "public static bool operator !=(tmp_Struct first, tmp_Struct second) { return first._value != second._value; }",
                "public override int GetHashCode() { return -1939223833 + _value.GetHashCode(); }",
                "public override bool Equals(object obj) { return this.CompareTo(obj) == 0; }",
                "public int CompareTo(object obj) { if (obj == null) return 1; if (obj is tmp_Interface conv) return this._value.CompareTo(conv.tmp_ToStruct()._value); throw new ArgumentException(\"obj is not from same dimension interface\"); }",
            });

            templates.AddRange(new[]
            {
                "public override string ToString() { return $\"{_value.ToString(CultureInfo.InvariantCulture)} \"+\"tmp_UnitShort\"; }",
            });


            foreach (var template in templates)
            {
                var declaration = SyntaxFactory.ParseMemberDeclaration(template)!;

                //replace struct name
                while (declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Any(d => d.Identifier.Text == "tmp_Struct"))
                {
                    var identifierNode = declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Where(d => d.Identifier.Text == "tmp_Struct").First();

                    declaration = declaration.ReplaceNode(identifierNode, SyntaxFactory.IdentifierName(unitClassName));
                }

                //replace interface name
                while (declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Any(d => d.Identifier.Text == "tmp_Interface"))
                {
                    var identifierNode = declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Where(d => d.Identifier.Text == "tmp_Interface").First();

                    declaration = declaration.ReplaceNode(identifierNode, SyntaxFactory.IdentifierName("I" + dimensionClassName));
                }

                //replace ToStruct
                while (declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Any(d => d.Identifier.Text == "tmp_ToStruct"))
                {
                    var identifierNode = declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Where(d => d.Identifier.Text == "tmp_ToStruct").First();

                    declaration = declaration.ReplaceNode(identifierNode, SyntaxFactory.IdentifierName("To" + unitClassName));
                }

                //replace unit identifier
                while (declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<LiteralExpressionSyntax>().Any(d => d.Token.ValueText == "tmp_UnitShort"))
                {
                    var literalExpression = declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<LiteralExpressionSyntax>().Where(d => d.Token.ValueText == "tmp_UnitShort").First();

                    declaration = declaration.ReplaceNode(literalExpression, SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(unitData.Symbol)));
                }

                yield return declaration;
            }
        }

        private IEnumerable<MemberDeclarationSyntax> GetStaticInterfaceMembers(string dimensionClassName, JsonDimension dimensionData)
        {
            var parseTemplates = new List<string>
            {
                "public static tmp_Interface Parse(string valueStr) { var idx = valueStr.IndexOf(\" \"); if (idx != -1) { var valuePart = valueStr.Substring(0, idx); if (!decimal.TryParse(valuePart, NumberStyles.Any, CultureInfo.InvariantCulture, out var val)) { throw new ArgumentException($\"Value could not be parsed. {valuePart}\"); } return Parse(valueStr.Substring(idx + 1), val); } throw new ArgumentException($\"Unit not recognizable from input string. {valueStr}\"); }",
                $"public static string DefaultImperial => \"{dimensionData.Units[dimensionData.ImperialDefault].Symbol}\";",
                $"public static string DefaultMetric => \"{dimensionData.Units[dimensionData.MetricDefault].Symbol}\";",
            };


            foreach (var parseSimpleTemplate in parseTemplates)
            {
                var parseDeclaration = SyntaxFactory.ParseMemberDeclaration(parseSimpleTemplate)!;

                while (parseDeclaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Any(d => d.Identifier.Text == "tmp_Interface"))
                {
                    var identifierNode = parseDeclaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Where(d => d.Identifier.Text == "tmp_Interface").First();
                    parseDeclaration = parseDeclaration.ReplaceNode(identifierNode, SyntaxFactory.IdentifierName("I" + dimensionClassName));
                }

                yield return parseDeclaration;
            }

            var parseTemplate = "public static tmp_Interface Parse(string symbolOrKey, decimal value) { switch (symbolOrKey){ } throw new NotSupportedException($\"Symbol {symbolOrKey} not supported.\"); }";

            var declaration = (SyntaxFactory.ParseMemberDeclaration(parseTemplate) as MethodDeclarationSyntax)!;

            while (declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Any(d => d.Identifier.Text == "tmp_Interface"))
            {
                var identifierNode = declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Where(d => d.Identifier.Text == "tmp_Interface").First();
                declaration = declaration.ReplaceNode(identifierNode, SyntaxFactory.IdentifierName("I" + dimensionClassName));
            }

            var originalSwitch = declaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<SwitchStatementSyntax>().Single();

            var newSwitch = originalSwitch;

            List<string> usedUnitLabels = new List<string>();

            foreach ((var unitName, var unitData) in dimensionData.Units)
            {
                var unitClassName = unitName.GetClassName();

                var switchLabels = SyntaxFactory.List<SwitchLabelSyntax>();
                switchLabels = switchLabels.Add(SyntaxFactory.CaseSwitchLabel(SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(unitData.Symbol))));
                switchLabels = switchLabels.Add(SyntaxFactory.CaseSwitchLabel(SyntaxFactory.LiteralExpression(SyntaxKind.StringLiteralExpression, SyntaxFactory.Literal(dimensionClassName + "_" + unitClassName))));

                string parserReturnTemplate = "return new tmp_Struct(value);";

                var returnDeclaration = SyntaxFactory.ParseStatement(parserReturnTemplate);

                //replace struct name
                while (returnDeclaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Any(d => d.Identifier.Text == "tmp_Struct"))
                {
                    var identifierNode = returnDeclaration.DescendantNodesAndTokens().Where(d => d.IsNode).Select(d => d.AsNode()).OfType<IdentifierNameSyntax>().Where(d => d.Identifier.Text == "tmp_Struct").First();

                    returnDeclaration = returnDeclaration.ReplaceNode(identifierNode, SyntaxFactory.IdentifierName(dimensionClassName + "Dimension." + unitClassName));
                }

                newSwitch = newSwitch.AddSections(SyntaxFactory.SwitchSection(switchLabels, SyntaxFactory.List<StatementSyntax>().Add(returnDeclaration)));
            }

            declaration = declaration.ReplaceNode(originalSwitch, newSwitch);

            yield return declaration;
        }
    }
}
